### VO(Value Object)에 관하여. 

출처 : http://aeternum.egloos.com/

애플리케이션을 구성하는 객체들을 Reference Object와 Value Object로 나뉜다.

Reference Object는 고객, 주문과 같이 실 세계의 추적 가능한 개념을 표현한다. 

이 말의 의미는 영화를 예매한 김철수라는 사람은 식별가능해야 한다는 의미이다. 

Value Object는 날짜, 금액과 같은 것들이다.

단지 객체를 구성하는 속성들의 값에만 초점을 맞출 뿐 객체의 추적 가능성에 대해 관심을 두지 않는다.

출금한 10,000원 짜리 지폐가 한달 전에 입금한 10,000원짜리 지폐와 동일해야할 이유는 없다. 단지, 10,000원이라는
금액이 정확히 인출되었는지 여부가 중요할 뿐이다.

Reference Object는 유일하기 때문에 동일성 확인 시에 ==를 사용하지만 Value Object의 경우 equals()를 사용하여
속성의 값의 동등성을 비교해야 한다.

근본적으로 Reference Object와 Value Object를 나누는 이유가 무엇일까?

이에 대한 해답은 Reference Object 대신 Value Object를 사용함으로써 별칭 문제를 피할 수 있기 때문이다.

메소드 인자에 final을 사용한다고 해도 별칭 문제를 막을 수 없다. 
java의 final은 C++의 const와 달리 단지 메소드 내부에서 다른 객체를 참조하지 않도록 막아 주는 역할만을 할 뿐이다. 
객체가 final로 전달되더라도 전달된 객체 자체의 상태를 바꾸는 것이 가능하다는 사실에 주의하자.

객체를 메소드의 인자로 전달할 경우 주의해야 할 사항들이다.

- 인자를 전달하는 동안 별칭(aliasing)이 자동으로 생성된다.
- 지역 객체란 존재하지 않는다. 다만 지역 참조만이 존재할 뿐이다.
- 참조는 범위(scope)를 가지지만 객체는 그렇지 않다.
- 객체의 생명주기는 java에서 이슈가 아니다.
- java에는 오브젝트의 수정과 별칭의 부정적인 영향을 막을(const와 같은) 언어적인 지원 메커니즘이 존재하지 않는다. 
인자 목록에 final을 사용할 수는 있지만 이것은 단순히 참조가 다른 객체와 다시 묶이는 것을 막아줄 뿐이다.

좋은 객체 지향 습관을 따른다면 인자로 전달된 객체의 상태를 바꾸는 메소드는 작성하지 않을 것이다. 

별칭 문제를 해결하기 위한 가장 좋은 방법은 객체를 변경할 수 없는 불변 상태로 만드는 것이다.
 
전달된 객체가 변경될 수 없다면 메소드에 객체를 전달한다고 하더라도 별칭을 통한 부작용을 막을 수 있다.

#### 불변성(Immutable)

불변 클래스는 다음과 같은 규칙을 따른다.

- 객체를 변경하는 메소드(mutator)를 제공하지 않는다.
- 재정의할 수 있는 메소드를 제공하지 않는다.
- 모든 필드를 final로 만든다.
- 모든 필드를 private으로 만든다.
- 가변 객체를 참조하는 필드는 배타적으로 접근해야 한다.


#### VO(Value Object)와 불변성(Immutable)

객체를 불변으로 만들면 별칭 문제를 피할 수 있다. 객체의 상태를 바꿀 수는 없으므로 새로운 상태로 변경해야 할 경우
 새로운 불변 객체를 만들어 기존의 불변 객체를 대체 시켜야 한다. 객체가 불변이라면 객체를 어디에 어떤 방식으로 노출
 시키더라도 예상하지 못한 사이드 이펙트로 인해 놀랄 일은 없어질 것이다.
 
결론부터 이야기하자면 VALUE OBJECT는 불변 객체여야 한다. VALUE OBJECT는 속성을 바꿀 수 없으며 새로운 값이 필요할 경우 기존 객체의 상태를 변경하는 대신 새로운 VALUE OBJECT를 생성해서 이를 대체해야 한다. 
10,000원이 들어 있는 지갑의 금액을 20,000원으로 변경하고 싶다면 기존의 지갑과 연결되어 있는 Money 객체의 속성 값을 10,000에서 20,000으로 변경시키는 것이 아니라 20,000원을 속성 값으로 가지는 Money 객체를 새로 생성한 후 
기존의 Money 객체 대신 새로 생성된 Money 객체를 지갑 객체와 연결시킨다. 
이제 10,000원을 속성으로 가지고 있던 기존의 Money 객체는 가비지 컬렉션의 대상이 될 것이다.

VALUE OBJECT를 불변 객체로 만드는 이유는 별칭 문제와 같이 골치 아픈 문제를 피할 수 있기 때문이다. 
VALUE OBJECT는 일반적으로 날짜, 금액과 같이 작은 개념을 의미하기 때문에 새로운 객체를 만들어 대체할 경우의 오버헤드가 적다. 
추적성에도 관심을 가질 필요가 없기 때문에 굳이 동일한 객체를 계속 유지하고 있을 필요가 없다.

VALUE OBJECT는 전체 도메인의 복잡성을 낮추는 유용한 분석 개념이다. 풍부한 도메인 모델(rich domain model)의 작성을 위해서는 유용하지만 비즈니스 적인 관점에서 가치가 없는 작은 개념을 VALUE OBJECT로 모델링함으로써 추적성과 별칭 문제에 대한 부담 없이 해당 객체를 참조할 수 있도록 한다. 
어떤 개념을 VALUE OBJECT로 취급하는 순간 해당 객체의 생명 주기가 얼마나 단순해질 지를 상상해 보라.

